from dataclasses import dataclass
from typing import Dict, Optional

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from supertrend_strategy import implement_supertrend_signals

__all__ = [
    "BacktestResult",
    "backtest_signals",
    "plot_results",
    "run_supertrend_backtest",
]


@dataclass
class BacktestResult:
    """
    Structured container returned by backtesting routines.
    """

    dataframe: pd.DataFrame
    equity_curve: pd.Series
    metrics: Dict[str, float]
    strategy_name: str
    parameters: Dict[str, float]

    def summary(self) -> Dict[str, float]:
        """
        Accessor returning the dict of calculated metrics.
        """
        return self.metrics


def backtest_signals(
    df: pd.DataFrame,
    *,
    signal_column: str = "signal",
    price_column: str = "close",
    initial_capital: float = 10_000.0,
    strategy_name: str = "Strategy",
    parameters: Optional[Dict[str, float]] = None,
) -> BacktestResult:
    """
    Generic long-only backtest that consumes a dataframe of OHLC prices and trading signals.

    A position is considered open after a +1 signal and closed after a -1 signal. Signals
    are assumed to be mutually exclusive (no overlapping positions).

    Parameters
    ----------
    df : pandas.DataFrame
        Historical data containing at least the specified signal and price columns.
    signal_column : str, default "signal"
        Column containing discrete trade events (+1 enter long, -1 exit, 0 otherwise).
    price_column : str, default "close"
        Column representing the close price used to compute returns.
    initial_capital : float, default 10_000.0
        Starting equity for the simulation.
    strategy_name : str, default "Strategy"
        Name that will be stored in the result metadata.
    parameters : dict[str, float], optional
        Optional dictionary of strategy parameters for reporting.

    Returns
    -------
    BacktestResult
        Structured object containing the enriched dataframe, equity curve, metrics, and metadata.
    """
    if parameters is None:
        parameters = {}

    if df.empty:
        raise ValueError("Cannot backtest an empty dataframe.")

    if signal_column not in df.columns:
        raise ValueError(f"Dataframe must include '{signal_column}' column generated by the strategy.")
    if price_column not in df.columns:
        raise ValueError(f"Dataframe must include '{price_column}' price column.")

    bt = df.copy()
    signals = bt[signal_column].fillna(0)

    bt["position"] = signals.cumsum().clip(lower=0, upper=1)
    bt["returns"] = bt[price_column].pct_change().fillna(0.0)
    bt["strategy_returns"] = bt["position"].shift(1).fillna(0.0) * bt["returns"]

    bt["cumulative_returns"] = (1 + bt["returns"]).cumprod()
    bt["cumulative_strategy_returns"] = (1 + bt["strategy_returns"]).cumprod()

    bt["peak"] = bt["cumulative_strategy_returns"].cummax()
    bt["drawdown"] = bt["cumulative_strategy_returns"] / bt["peak"] - 1

    total_return = bt["cumulative_strategy_returns"].iloc[-1] - 1
    max_drawdown = bt["drawdown"].min()

    trading_returns = bt["strategy_returns"]
    volatility = trading_returns.std(ddof=0)
    sharpe_ratio = np.nan
    if volatility > 0:
        sharpe_ratio = (trading_returns.mean() / volatility) * np.sqrt(252)

    bt["equity"] = initial_capital * bt["cumulative_strategy_returns"]

    metrics = {
        "total_return": float(total_return),
        "max_drawdown": float(max_drawdown),
        "sharpe_ratio": float(sharpe_ratio) if not np.isnan(sharpe_ratio) else np.nan,
    }

    return BacktestResult(
        dataframe=bt,
        equity_curve=bt["equity"],
        metrics=metrics,
        strategy_name=strategy_name,
        parameters=parameters,
    )


def _format_percent(value: float) -> str:
    return f"{value:.2%}" if pd.notna(value) else "n/a"


def _format_float(value: float) -> str:
    return f"{value:.2f}" if pd.notna(value) else "n/a"


def plot_results(result: BacktestResult) -> None:
    """
    Render a Matplotlib overview of price action, trade signals, and equity curve.
    """
    bt = result.dataframe

    fig = plt.figure(figsize=(12, 8))

    ax_price = fig.add_subplot(2, 1, 1)
    ax_price.plot(bt.index, bt["close"], label="Price", color="black")
    ax_price.plot(
        bt[bt["signal"] == 1].index,
        bt["close"][bt["signal"] == 1],
        "^",
        markersize=8,
        color="green",
        label="Buy",
    )
    ax_price.plot(
        bt[bt["signal"] == -1].index,
        bt["close"][bt["signal"] == -1],
        "v",
        markersize=8,
        color="red",
        label="Sell",
    )

    if "supertrend" in bt.columns:
        ax_price.plot(
            bt.index,
            bt["supertrend"],
            label="Supertrend",
            linestyle="--",
            linewidth=1,
            color="dodgerblue",
        )

    ax_price.set_title(f"{result.strategy_name} Signals")
    ax_price.legend()

    ax_equity = fig.add_subplot(2, 1, 2, sharex=ax_price)
    ax_equity.plot(bt.index, result.equity_curve, label="Equity", color="navy")
    metrics = result.metrics
    subtitle = (
        f"Equity Curve (Total Return: {_format_percent(metrics.get('total_return', np.nan))}, "
        f"Max DD: {_format_percent(metrics.get('max_drawdown', np.nan))}, "
        f"Sharpe: {_format_float(metrics.get('sharpe_ratio', np.nan))})"
    )
    ax_equity.set_title(subtitle)
    ax_equity.legend()

    summary_text = (
        f"Total Return: {_format_percent(metrics.get('total_return', np.nan))}\n"
        f"Max DD: {_format_percent(metrics.get('max_drawdown', np.nan))}\n"
        f"Sharpe: {_format_float(metrics.get('sharpe_ratio', np.nan))}"
    )
    fig.text(
        0.02,
        0.95,
        summary_text,
        ha="left",
        va="top",
        fontsize=10,
        bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.6),
    )

    buy_points = bt[bt["signal"] == 1]["close"]
    for ts, price in buy_points.items():
        label = f"Buy\n{price:.2f}"
        ax_price.annotate(
            label,
            xy=(ts, price),
            xytext=(0, 16),
            textcoords="offset points",
            color="green",
            fontsize=8,
            fontweight="bold",
            ha="center",
            va="bottom",
            bbox=dict(boxstyle="round,pad=0.2", fc="white", ec="green", alpha=0.75),
        )

    sell_points = bt[bt["signal"] == -1]["close"]
    for ts, price in sell_points.items():
        label = f"Sell\n{price:.2f}"
        ax_price.annotate(
            label,
            xy=(ts, price),
            xytext=(0, -20),
            textcoords="offset points",
            color="red",
            fontsize=8,
            fontweight="bold",
            ha="center",
            va="top",
            bbox=dict(boxstyle="round,pad=0.2", fc="white", ec="red", alpha=0.75),
        )

    fig.tight_layout()
    plt.show()


def run_supertrend_backtest(
    df: pd.DataFrame,
    *,
    atr_period: int = 10,
    multiplier: float = 3.0,
    initial_capital: float = 10000.0,
    visualize: bool = False,
    output_path: Optional[str] = None,
    show: bool = True,
) -> BacktestResult:
    """
    Convenience wrapper that prepares Supertrend signals then delegates to the generic backtester.
    """
    parameters = {"atr_period": atr_period, "multiplier": multiplier}
    enriched = implement_supertrend_signals(df, atr_period=atr_period, multiplier=multiplier)
    result = backtest_signals(
        enriched,
        signal_column="signal",
        price_column="close",
        initial_capital=initial_capital,
        strategy_name="Supertrend",
        parameters=parameters,
    )

    if visualize:
        from visualization.kline import render_kline

        render_kline(result, show=show, output_path=output_path)

    return result


if __name__ == "__main__":
    import data.ohlcv_loader as ohlcv_loader

    symbol = "BTC/USDT"
    df = ohlcv_loader.load_recent_daily(symbol, days=365, refresh_live_close=True)
    
    result = run_supertrend_backtest(
        df,
        atr_period=3,
        multiplier=1.0,
        initial_capital=10000.0,
        visualize=True,
        show=True,
    )

    print("Backtest Summary:")
    for k, v in result.summary().items():
        print(f"  {k}: {v:.4f}")